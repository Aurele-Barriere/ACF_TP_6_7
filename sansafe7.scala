// Code generated by Isabelle
package tp67

import utilities.Datatype._
// automatic conversion of utilities.Datatype.Int.int to tp67.Int.int
object AutomaticConversion{ 
	implicit def int2int(i:utilities.Datatype.Int.int):tp67.Int.int =
			i match {
			case utilities.Datatype.Int.int_of_integer(i)=>tp67.Int.int_of_integer(i)
	}
}
import AutomaticConversion._


object HOL {

trait equal[A] {
  val `HOL.equal`: (A, A) => Boolean
}
def equal[A](a: A, b: A)(implicit A: equal[A]): Boolean = A.`HOL.equal`(a, b)

def eq[A : equal](a: A, b: A): Boolean = equal[A](a, b)

} /* object HOL */

object Code_Numeral {

def integer_of_int(x0: Int.int): BigInt = x0 match {
  case Int.int_of_integer(k) => k
}

} /* object Code_Numeral */

object Int {

abstract sealed class int
final case class int_of_integer(a: BigInt) extends int

def equal_inta(k: int, l: int): Boolean =
  Code_Numeral.integer_of_int(k) == Code_Numeral.integer_of_int(l)

implicit def equal_int: HOL.equal[int] = new HOL.equal[int] {
  val `HOL.equal` = (a: int, b: int) => equal_inta(a, b)
}

def plus_int(k: int, l: int): int =
  int_of_integer(Code_Numeral.integer_of_int(k) +
                   Code_Numeral.integer_of_int(l))

def zero_int: int = int_of_integer(BigInt(0))

def minus_int(k: int, l: int): int =
  int_of_integer(Code_Numeral.integer_of_int(k) -
                   Code_Numeral.integer_of_int(l))

def uminus_int(k: int): int =
  int_of_integer((- (Code_Numeral.integer_of_int(k))))

} /* object Int */

object Num {

abstract sealed class num
final case class One() extends num
final case class Bit0(a: num) extends num
final case class Bit1(a: num) extends num

} /* object Num */

object String {

implicit def equal_char: HOL.equal[Char] = new HOL.equal[Char] {
  val `HOL.equal` = (a: Char, b: Char) => a == b
}

} /* object String */

object Lista {

def equal_lista[A : HOL.equal](x0: List[A], x1: List[A]): Boolean = (x0, x1)
  match {
  case (Nil, x21 :: x22) => false
  case (x21 :: x22, Nil) => false
  case (x21 :: x22, y21 :: y22) =>
    HOL.eq[A](x21, y21) && equal_lista[A](x22, y22)
  case (Nil, Nil) => true
}

implicit def equal_list[A : HOL.equal]: HOL.equal[List[A]] = new
  HOL.equal[List[A]] {
  val `HOL.equal` = (a: List[A], b: List[A]) => equal_lista[A](a, b)
}

} /* object Lista */

object tp67 {

import /*implicits*/ Int.equal_int, String.equal_char, Lista.equal_list

abstract sealed class option[A]
final case class Nonea[A]() extends option[A]
final case class Somea[A](a: A) extends option[A]

abstract sealed class abs_bool
final case class ATrue() extends abs_bool
final case class AFalse() extends abs_bool
final case class AAny() extends abs_bool

abstract sealed class Labstract
final case class LAny() extends Labstract
final case class LDefined(a: List[Int.int]) extends Labstract

def equal_Labstract(x0: Labstract, x1: Labstract): Boolean = (x0, x1) match {
  case (LAny(), LDefined(list)) => false
  case (LDefined(list), LAny()) => false
  case (LDefined(lista), LDefined(list)) =>
    Lista.equal_lista[Int.int](lista, list)
  case (LAny(), LAny()) => true
}

def equal_abs_bool(x0: abs_bool, x1: abs_bool): Boolean = (x0, x1) match {
  case (AFalse(), AAny()) => false
  case (AAny(), AFalse()) => false
  case (ATrue(), AAny()) => false
  case (AAny(), ATrue()) => false
  case (ATrue(), AFalse()) => false
  case (AFalse(), ATrue()) => false
  case (AAny(), AAny()) => true
  case (AFalse(), AFalse()) => true
  case (ATrue(), ATrue()) => true
}

def labstract_union(x0: Labstract, uu: Labstract): Labstract = (x0, uu) match {
  case (LAny(), uu) => LAny()
  case (LDefined(v), LAny()) => LAny()
  case (LDefined(l1), LDefined(l2)) => LDefined(l1 ++ l2)
}

def LallAny(x0: List[(List[Char], Labstract)]): List[(List[Char], Labstract)] =
  x0 match {
  case Nil => Nil
  case (s, a) :: t => (s, LAny()) :: LallAny(t)
}

def assoc[A : HOL.equal, B](uu: A, x1: List[(A, B)]): option[B] = (uu, x1) match
  {
  case (uu, Nil) => Nonea[B]()
  case (x1, (x, y) :: xs) =>
    (if (HOL.eq[A](x, x1)) Somea[B](y) else assoc[A, B](x1, xs))
}

def LBothTables(x0: List[(List[Char], Labstract)],
                 t2: List[(List[Char], Labstract)]):
      List[(List[Char], Labstract)]
  =
  (x0, t2) match {
  case (Nil, t2) => LallAny(t2)
  case ((s, a) :: t, t2) =>
    (assoc[List[Char], Labstract](s, t2) match {
       case Nonea() => (s, LAny()) :: LBothTables(t, t2)
       case Somea(x) =>
         (if (equal_Labstract(x, a)) (s, a) :: LBothTables(t, t2)
           else (s, labstract_union(x, a)) :: LBothTables(t, t2))
     })
}

def op_list_el(bop: Int.int => Int.int => Int.int, e: Int.int,
                x2: List[Int.int]):
      List[Int.int]
  =
  (bop, e, x2) match {
  case (bop, e, Nil) => Nil
  case (bop, e, h :: t) => (bop(e))(h) :: op_list_el(bop, e, t)
}

def op_lists(bop: Int.int => Int.int => Int.int, x1: List[Int.int],
              t2: List[Int.int]):
      List[Int.int]
  =
  (bop, x1, t2) match {
  case (bop, Nil, t2) => Nil
  case (bop, h1 :: t1, t2) => op_list_el(bop, h1, t2) ++ op_lists(bop, t1, t2)
}

def Labs_plus(x0: Labstract, uu: Labstract): Labstract = (x0, uu) match {
  case (LAny(), uu) => LAny()
  case (LDefined(v), LAny()) => LAny()
  case (LDefined(n1), LDefined(n2)) =>
    LDefined(op_lists((a: Int.int) => (b: Int.int) => Int.plus_int(a, b), n1,
                       n2))
}

def Labs_sub(x0: Labstract, uu: Labstract): Labstract = (x0, uu) match {
  case (LAny(), uu) => LAny()
  case (LDefined(v), LAny()) => LAny()
  case (LDefined(n1), LDefined(n2)) =>
    LDefined(op_lists((a: Int.int) => (b: Int.int) => Int.minus_int(a, b), n1,
                       n2))
}

def LAevalE(x0: expression, e: List[(List[Char], Labstract)]): Labstract =
  (x0, e) match {
  case (Constant(s), e) => LDefined(List(s))
  case (Variable(s), e) =>
    (assoc[List[Char], Labstract](s, e) match {
       case Nonea() =>
         LDefined(List(Int.uminus_int(Int.int_of_integer(BigInt(1)))))
       case Somea(y) => y
     })
  case (Sum(e1, e2), e) => Labs_plus(LAevalE(e1, e), LAevalE(e2, e))
  case (Sub(e1, e2), e) => Labs_sub(LAevalE(e1, e), LAevalE(e2, e))
}

def Labs_eq(x0: Labstract, uu: Labstract): abs_bool = (x0, uu) match {
  case (LAny(), uu) => AAny()
  case (LDefined(v), LAny()) => AAny()
  case (LDefined(List(a1)), LDefined(List(a2))) =>
    (if (Int.equal_inta(a1, a2)) ATrue() else AFalse())
  case (LDefined(Nil), LDefined(va)) => AAny()
  case (LDefined(vb :: vd :: ve), LDefined(va)) => AAny()
  case (LDefined(v), LDefined(Nil)) => AAny()
  case (LDefined(v), LDefined(vb :: vd :: ve)) => AAny()
}

def LAevalC(x0: condition, t: List[(List[Char], Labstract)]): abs_bool = (x0, t)
  match {
  case (Eq(e1, e2), t) => Labs_eq(LAevalE(e1, t), LAevalE(e2, t))
}

def LAevalS(xa0: statement, x: (List[(List[Char], Labstract)], Boolean)):
      (List[(List[Char], Labstract)], Boolean)
  =
  (xa0, x) match {
  case (Skip, x) => x
  case (Aff(s, e), (t, b)) => ((s, LAevalE(e, t)) :: t, b)
  case (If(c, s1, s2), (t, b)) =>
    {
      val r: abs_bool = LAevalC(c, t);
      (if (equal_abs_bool(r, ATrue())) LAevalS(s1, (t, b))
        else (if (equal_abs_bool(r, AFalse())) LAevalS(s2, (t, b))
               else {
                      val (t1, b1): (List[(List[Char], Labstract)], Boolean) =
                        LAevalS(s1, (t, b))
                      val (t2, b2): (List[(List[Char], Labstract)], Boolean) =
                        LAevalS(s2, (t, b))
                      val b3: Boolean = b1 && b2
                      val t3: List[(List[Char], Labstract)] =
                        LBothTables(t1, t2);
                      (t3, b3)
                    }))
    }
  case (Seq(s1, s2), (t, b)) =>
    {
      val (t2, b2): (List[(List[Char], Labstract)], Boolean) =
        LAevalS(s1, (t, b));
      LAevalS(s2, (t2, b2))
    }
  case (Read(s), (t, b)) => ((s, LAny()) :: t, b)
  case (Print(e), (t, b)) => (t, b)
  case (Exec(e), (t, b)) =>
    {
      val r: Labstract = LAevalE(e, t);
      (if (equal_Labstract(r, LAny()) ||
             equal_Labstract(r, LDefined(List(Int.zero_int))))
        (t, false) else (t, b))
    }
}

def san7(s: statement): Boolean =
  {
    val (_, b): (List[(List[Char], Labstract)], Boolean) =
      LAevalS(s, (Nil, true));
    b
  }

def safe(s: statement): Boolean = san7(s)

} /* object tp67 */
