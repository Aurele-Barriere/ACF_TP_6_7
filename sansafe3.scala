// Code generated by Isabelle
package tp67

import utilities.Datatype._
// automatic conversion of utilities.Datatype.Int.int to tp67.Int.int
object AutomaticConversion{ 
	implicit def int2int(i:utilities.Datatype.Int.int):tp67.Int.int =
			i match {
			case utilities.Datatype.Int.int_of_integer(i)=>tp67.Int.int_of_integer(i)
	}
}
import AutomaticConversion._


object HOL {

trait equal[A] {
  val `HOL.equal`: (A, A) => Boolean
}
def equal[A](a: A, b: A)(implicit A: equal[A]): Boolean = A.`HOL.equal`(a, b)

def eq[A : equal](a: A, b: A): Boolean = equal[A](a, b)

} /* object HOL */

object Code_Numeral {

def integer_of_int(x0: Int.int): BigInt = x0 match {
  case Int.int_of_integer(k) => k
}

} /* object Code_Numeral */

object Int {

abstract sealed class int
final case class int_of_integer(a: BigInt) extends int

def equal_inta(k: int, l: int): Boolean =
  Code_Numeral.integer_of_int(k) == Code_Numeral.integer_of_int(l)

implicit def equal_int: HOL.equal[int] = new HOL.equal[int] {
  val `HOL.equal` = (a: int, b: int) => equal_inta(a, b)
}

def plus_int(k: int, l: int): int =
  int_of_integer(Code_Numeral.integer_of_int(k) +
                   Code_Numeral.integer_of_int(l))

def zero_int: int = int_of_integer(BigInt(0))

def minus_int(k: int, l: int): int =
  int_of_integer(Code_Numeral.integer_of_int(k) -
                   Code_Numeral.integer_of_int(l))

} /* object Int */

object tp67 {

import /*implicits*/ Int.equal_int

abstract sealed class option[A]
final case class Nonea[A]() extends option[A]
final case class Somea[A](a: A) extends option[A]

def equal_option[A : HOL.equal](x0: option[A], x1: option[A]): Boolean =
  (x0, x1) match {
  case (Nonea(), Somea(a)) => false
  case (Somea(a), Nonea()) => false
  case (Somea(aa), Somea(a)) => HOL.eq[A](aa, a)
  case (Nonea(), Nonea()) => true
}

def optionOp(x0: (option[Int.int],
                   (option[Int.int], Int.int => Int.int => Int.int))):
      option[Int.int]
  =
  x0 match {
  case (Nonea(), (y, f)) => Nonea[Int.int]()
  case (Somea(v), (Nonea(), f)) => Nonea[Int.int]()
  case (Somea(a1), (Somea(a2), f)) => Somea[Int.int]((f(a1))(a2))
}

def noVarEval(x0: expression): option[Int.int] = x0 match {
  case Constant(c) => Somea[Int.int](c)
  case Variable(uu) => Nonea[Int.int]()
  case Sum(e1, e2) =>
    optionOp((noVarEval(e1),
               (noVarEval(e2),
                 (a: Int.int) => (b: Int.int) => Int.plus_int(a, b))))
  case Sub(e1, e2) =>
    optionOp((noVarEval(e1),
               (noVarEval(e2),
                 (a: Int.int) => (b: Int.int) => Int.minus_int(a, b))))
}

def san3(x0: statement): Boolean = x0 match {
  case Exec(e) =>
    (if (equal_option[Int.int](noVarEval(e), Somea[Int.int](Int.zero_int)) ||
           equal_option[Int.int](noVarEval(e), Nonea[Int.int]()))
      false else true)
  case Seq(h, t) => san3(h) && san3(t)
  case If(b, s1, s2) => san3(s1) && san3(s2)
  case Aff(v, va) => true
  case Read(v) => true
  case Print(v) => true
  case Skip => true
}

def safe(s: statement): Boolean = san3(s)

} /* object tp67 */
